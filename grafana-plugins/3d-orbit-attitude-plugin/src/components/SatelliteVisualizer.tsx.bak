/**
 * SatelliteVisualizer.tsx
 * 
 * Main panel component for 3D satellite visualization using CesiumJS.
 * 
 * ARCHITECTURE (Post-Refactoring, Jan 14 2026):
 * This component is now focused on orchestration and state management.
 * 
 * REFACTORING HISTORY:
 * - Dec 31, 2025: Entity Renderers extracted ‚Üí ./entities/CesiumEntityRenderers.tsx
 * - Jan 14, 2026: Phase 1 - Styles & Constants extracted ‚Üí ./styles/
 * 
 * CURRENT SIZE: 1726 lines (down from 2589 lines before Phase 1)
 * 
 * RESPONSIBILITIES:
 * ‚úì State management (satellites, tracking, visibility, UI toggles)
 * ‚úì Cesium viewer initialization and configuration
 * ‚úì Camera controls (tracking mode, free camera, nadir view)
 * ‚úì UI controls (sidebar, buttons, modals)
 * ‚úì Data parsing and preprocessing
 * ‚úì Coordinating child renderer components
 * 
 * RENDERING DELEGATION:
 * All 3D entity rendering is delegated to specialized components:
 * - SatelliteEntityRenderer: Main satellite model/point + trajectory
 * - SensorVisualizationRenderer: Sensor cones + FOV projections
 * - BodyAxesRenderer: Satellite body axes (X/Y/Z)
 * - CelestialGridRenderer: RA/Dec celestial coordinate grid
 * - GroundStationRenderer: Ground station markers
 * - UncertaintyEllipsoidRenderer: Uncertainty ellipsoid visualization
 * - CelestialBodiesRenderer: Sun and Earth center symbols for celestial map
 * 
 * STYLES & CONSTANTS:
 * - ./styles/SatelliteVisualizerStyles.ts: All CSS-in-JS styles
 * - ./styles/constants.ts: Color maps and color parsing utilities
 * 
 * See: 
 * - grafana-plugins/plans-broad-scope/25-12-december/31-refactoring-complete-summary.md
 * - grafana-plugins/plans-broad-scope/26-01-january/01-refactoring-analysis-and-strategy.md
 */

import React, { useEffect, useState, useCallback } from 'react';
import { PanelProps, DataHoverEvent, LegacyGraphHoverEvent } from '@grafana/data';
import { SimpleOptions } from 'types';
import { generateRADecGrid, generateRADecGridLabels } from 'utils/celestialGrid';
import { parseSatellites } from 'parsers/satelliteParser';
import { ParsedSatellite } from 'types/satelliteTypes';
import { parseGroundStations } from 'parsers/groundStationParser';
import { GroundStation } from 'types/groundStationTypes';
import {
  SatelliteEntityRenderer,
  SensorVisualizationRenderer,
  BodyAxesRenderer,
  CelestialGridRenderer,
  GroundStationRenderer,
  UncertaintyEllipsoidRenderer,
  CelestialBodiesRenderer,
} from './entities/CesiumEntityRenderers';
import { css, cx } from '@emotion/css';
import { useStyles2, ColorPicker } from '@grafana/ui';
import { Eye, EyeOff, Settings, X, ChevronUp } from 'lucide-react';
import { getStyles } from './styles/SatelliteVisualizerStyles';
import { safeColor } from './styles/constants';
import { TopLeftControls } from './controls/TopLeftControls';
import { SidebarControls } from './controls/SidebarControls';

import { Viewer, Clock, Entity, PointGraphics, LabelGraphics } from 'resium';
import {
  Ion,
  JulianDate,
  TimeInterval,
  Cartesian3,
  Transforms,
  Color,
  IonResource,
  Cartesian2,
  Ellipsoid,
  UrlTemplateImageryProvider,
  ProviderViewModel,
  buildModuleUrl,
  ScreenSpaceEventHandler,
  ScreenSpaceEventType,
  LabelStyle,
} from 'cesium';

import 'cesium/Build/Cesium/Widgets/widgets.css';

interface Props extends PanelProps<SimpleOptions> {}

export const SatelliteVisualizer: React.FC<Props> = ({ options, data, timeRange, width, height, eventBus }) => {
  Ion.defaultAccessToken = options.accessToken;

  const styles = useStyles2(getStyles);

  const [isLoaded, setLoaded] = useState<boolean>(false);
  const [viewerKey, setViewerKey] = useState<number>(0);
  const [isTracked, setIsTracked] = useState<boolean>(true);
  const [isSidebarOpen, setIsSidebarOpen] = useState<boolean>(false);

  const [timestamp, setTimestamp] = useState<JulianDate | null>(null);
  const [satellites, setSatellites] = useState<ParsedSatellite[]>([]);
  const [groundStations, setGroundStations] = useState<GroundStation[]>([]);
  const [trackedSatelliteId, setTrackedSatelliteId] = useState<string | null>(null);
  const [hiddenSatellites, setHiddenSatellites] = useState<Set<string>>(new Set());
  const [hiddenGroundStations, setHiddenGroundStations] = useState<Set<string>>(new Set());
  const [settingsModalSatelliteId, setSettingsModalSatelliteId] = useState<string | null>(null);
  const [settingsModalGroundStationId, setSettingsModalGroundStationId] = useState<string | null>(null);
  const [activeTab, setActiveTab] = useState<'satellites' | 'groundstations'>('satellites');
  
  // New dropdown states for Mode and Camera controls
  const [isModeDropdownOpen, setIsModeDropdownOpen] = useState<boolean>(false);
  const [isCameraDropdownOpen, setIsCameraDropdownOpen] = useState<boolean>(false);
  const [isAxesDropdownOpen, setIsAxesDropdownOpen] = useState<boolean>(false);
  const [selectedMode, setSelectedMode] = useState<'satellite' | 'earth' | 'celestial'>('satellite');
  
  // Camera view states - different per mode
  const [satelliteCameraView, setSatelliteCameraView] = useState<'nadir' | 'lvlh' | 'fixed' | 'free'>('nadir');
  const [celestialCameraView, setCelestialCameraView] = useState<'sun' | 'lvlh-orbit' | 'star' | 'groundstation'>('sun');
  const [earthCameraView, setEarthCameraView] = useState<'icrf' | 'itrf' | 'gcrf' | 'teme'>('icrf');
  
  // Reference axes visibility toggles (common to all modes)
  const [showLVLHAxes, setShowLVLHAxes] = useState<boolean>(false);
  const [showBodyAxes, setShowBodyAxes] = useState<boolean>(true); // Default on
  const [showITRFAxes, setShowITRFAxes] = useState<boolean>(false);
  const [showICRFAxes, setShowICRFAxes] = useState<boolean>(false);
  
  // Legend panel state
  const [expandedLegendItem, setExpandedLegendItem] = useState<string | null>(null);
  const [isLegendCollapsed, setIsLegendCollapsed] = useState<boolean>(false);
  
  // Hover tooltip state
  const [hoveredEntityName, setHoveredEntityName] = useState<string | null>(null);
  const [tooltipPosition, setTooltipPosition] = useState<{ x: number; y: number } | null>(null);
  
  // Per-satellite render settings (for future features like transparent cones)
  const [satelliteRenderSettings, setSatelliteRenderSettings] = useState<Map<string, {
    transparentCones: boolean;
    showEllipsoid: boolean;
    // Future settings will go here
    setting2: boolean;
    setting3: boolean;
    setting4: boolean;
    setting5: boolean;
    setting6: boolean;
    setting7: boolean;
    setting8: boolean;
    setting9: boolean;
  }>>(new Map());

  // Sensor color overrides (localStorage persistence)
  const [sensorColors, setSensorColors] = useState<Map<string, Map<string, string>>>(new Map());
  
  // Color picker state - REMOVED: No longer needed, pickers always visible
  // const [colorPickerState, setColorPickerState] = useState<{
  //   satelliteId: string;
  //   sensorId: string;
  // } | null>(null);

  const [satelliteResource, setSatelliteResource] = useState<IonResource | string | undefined>(undefined);
  const [raLines, setRALines] = useState<Cartesian3[][]>([]);
  const [decLines, setDecLines] = useState<Cartesian3[][]>([]);
  const [gridLabels, setGridLabels] = useState<Array<{ position: Cartesian3; text: string }>>([]);
  
  // Store viewer reference for imagery setup in useEffect
  const viewerRef = React.useRef<any>(null);
  
  // Modal overlay refs for ESC key handling
  const satelliteModalRef = React.useRef<HTMLDivElement>(null);
  const groundStationModalRef = React.useRef<HTMLDivElement>(null);

  // Attitude vector configurations - single color with different brightness levels
  const attitudeVectors = React.useMemo(() => {
    // Use X-axis color as base, or default to cyan
    const baseColor = safeColor(options.xAxisColor, Color.CYAN);
    
    // Extract RGB values
    const r = baseColor.red;
    const g = baseColor.green;
    const b = baseColor.blue;
    
    // Create brightness variations: X (brightest), Y (medium), Z (darkest)
    return [
      { 
        axis: new Cartesian3(1, 0, 0), 
        color: Color.fromBytes(
          Math.min(255, Math.floor(r * 255 * 1.0)),
          Math.min(255, Math.floor(g * 255 * 1.0)),
          Math.min(255, Math.floor(b * 255 * 1.0))
        ), 
        name: 'X-axis' 
      },
      { 
        axis: new Cartesian3(0, 1, 0), 
        color: Color.fromBytes(
          Math.min(255, Math.floor(r * 255 * 0.7)),
          Math.min(255, Math.floor(g * 255 * 0.7)),
          Math.min(255, Math.floor(b * 255 * 0.7))
        ), 
        name: 'Y-axis' 
      },
      { 
        axis: new Cartesian3(0, 0, 1), 
        color: Color.fromBytes(
          Math.min(255, Math.floor(r * 255 * 0.4)),
          Math.min(255, Math.floor(g * 255 * 0.4)),
          Math.min(255, Math.floor(b * 255 * 0.4))
        ), 
        name: 'Z-axis' 
      },
    ];
  }, [options.xAxisColor]);

  // Color management helper functions
  // Note: Will be used in Phase 3 (display colors in UI) and Phase 4 (color picker)
  const _getSensorColor = (satelliteId: string, sensorId: string, sensor: any, defaultIndex: number): string => {
    // Priority 1: User override from localStorage
    const override = sensorColors.get(satelliteId)?.get(sensorId);
    if (override) {
      return override;
    }
    
    // Priority 2: Color from sensor JSON
    if (sensor.color) {
      return sensor.color;
    }
    
    // Priority 3: Default color palette
    const defaultColors = ['#00FFFF', '#FF00FF', '#FFFF00', '#FFA500', '#00FF00'];
    return defaultColors[defaultIndex % defaultColors.length];
  };

  const _updateSensorColor = (satelliteId: string, sensorId: string, color: string) => {
    const newColors = new Map(sensorColors);
    if (!newColors.has(satelliteId)) {
      newColors.set(satelliteId, new Map());
    }
    newColors.get(satelliteId)!.set(sensorId, color);
    setSensorColors(newColors);
    
    // Persist to localStorage
    const serialized = JSON.stringify(Array.from(newColors.entries()).map(([satId, sensors]) => [
      satId,
      Array.from(sensors.entries())
    ]));
    localStorage.setItem('grafana_satelliteVisualizer_sensorColors', serialized);
  };

  const _resetSensorColor = (satelliteId: string, sensorId: string) => {
    const newColors = new Map(sensorColors);
    newColors.get(satelliteId)?.delete(sensorId);
    if (newColors.get(satelliteId)?.size === 0) {
      newColors.delete(satelliteId);
    }
    setSensorColors(newColors);
    
    // Update localStorage
    const serialized = JSON.stringify(Array.from(newColors.entries()).map(([satId, sensors]) => [
      satId,
      Array.from(sensors.entries())
    ]));
    localStorage.setItem('grafana_satelliteVisualizer_sensorColors', serialized);
  };

  // Load color overrides from localStorage on mount
  useEffect(() => {
    try {
      const stored = localStorage.getItem('grafana_satelliteVisualizer_sensorColors');
      if (stored) {
        const parsed = JSON.parse(stored);
        const restored = new Map<string, Map<string, string>>(
          parsed.map(([satId, sensors]: [string, Array<[string, string]>]) => [
            satId,
            new Map<string, string>(sensors)
          ])
        );
        setSensorColors(restored);
        console.log('‚úÖ Loaded sensor color overrides from localStorage');
      }
    } catch (error) {
      console.warn('Failed to load sensor colors from localStorage:', error);
    }
  }, []);
  
  // Fly camera to satellite with "from above" nadir view
  const flyToSatelliteNadirView = useCallback((satelliteId: string, duration = 0.5, distance = 4) => {
    const viewer = viewerRef.current?.cesiumElement;
    if (!viewer) {
      return;
    }

    const satellite = satellites.find(s => s.id === satelliteId);
    if (!satellite) {
      return;
    }

    // Use current viewer clock time (not the timestamp state which may be stale)
    const currentTime = viewer.clock.currentTime;
    const satPos = satellite.position.getValue(currentTime);
    if (!satPos) {
      return;
    }

    // Calculate radial direction (Earth center ‚Üí Satellite)
    const radialDirection = Cartesian3.subtract(satPos, Cartesian3.ZERO, new Cartesian3());
    Cartesian3.normalize(radialDirection, radialDirection);

    // Position camera at specified distance above satellite along radial line
    const cameraPosition = Cartesian3.add(
      satPos,
      Cartesian3.multiplyByScalar(radialDirection, distance, new Cartesian3()),
      new Cartesian3()
    );

    // Camera looks at satellite (down toward Earth)
    viewer.camera.flyTo({
      destination: cameraPosition,
      orientation: {
        direction: Cartesian3.negate(radialDirection, new Cartesian3()), // Point toward Earth
        up: Cartesian3.UNIT_Z, // Keep "up" aligned with Earth's axis
      },
      duration: duration,
    });

    console.log(`üöÄ Flying to ${satellite.name} - Nadir View (${distance}m above, ${duration}s)`);
  }, [satellites, viewerRef]);
  
  // Auto-track satellite and adjust camera based on mode
  useEffect(() => {
    if (selectedMode === 'satellite' || selectedMode === 'celestial') {
      // Enable tracking for Satellite Focus and Celestial Map modes
      if (!isTracked) {
        setIsTracked(true);
        console.log(`üéØ Satellite tracking enabled (${selectedMode === 'satellite' ? 'Satellite Focus' : 'Celestial Map'} mode)`);
      }
    } else if (selectedMode === 'earth') {
      // Earth Focus mode: smooth transition to nadir view then enable free camera
      if (isTracked && trackedSatelliteId) {
        const earthRadius = 6378137; // meters
        const safeDistance = earthRadius * 2; // ~12,756 km (2x Earth radius)
        const duration = 1.5; // Smooth 1.5 second transition
        
        flyToSatelliteNadirView(trackedSatelliteId, duration, safeDistance);
        
        // Wait for animation to complete before activating free camera
        setTimeout(() => {
          setIsTracked(false);
          console.log('üåç Free camera enabled (Earth Focus mode - Nadir view)');
        }, duration * 1000 + 100); // Animation duration + small buffer
      }
    }
  }, [selectedMode, isTracked, trackedSatelliteId, flyToSatelliteNadirView]);

  // Focus satellite settings modal when it opens (for ESC key handling)
  useEffect(() => {
    if (settingsModalSatelliteId && satelliteModalRef.current) {
      satelliteModalRef.current.focus();
    }
  }, [settingsModalSatelliteId]);

  // Focus ground station settings modal when it opens (for ESC key handling)
  useEffect(() => {
    if (settingsModalGroundStationId && groundStationModalRef.current) {
      groundStationModalRef.current.focus();
    }
  }, [settingsModalGroundStationId]);
  
  // Hover detection for sensor cones
  useEffect(() => {
    const viewer = viewerRef.current?.cesiumElement;
    if (!viewer || !isLoaded) {
      return;
    }
    
    const handler = new ScreenSpaceEventHandler(viewer.scene.canvas);
    let hoverTimeout: NodeJS.Timeout | null = null;
    
    handler.setInputAction((movement: any) => {
      // Clear any pending timeout
      if (hoverTimeout) {
        clearTimeout(hoverTimeout);
      }
      
      const pickedObject = viewer.scene.pick(movement.endPosition);
      
      if (pickedObject && pickedObject.id && pickedObject.id.name) {
        const entityName = pickedObject.id.name;
        
        // Filter for sensor-related entities (containing FOV info, Footprint, or Celestial)
        // Sensor cones: "SatName - SensorName (FOV: XX¬∞)"
        // Footprints: "SatName - SensorName Footprint"
        // Celestial: "SatName - SensorName Celestial FOV"
        const isSensorEntity = entityName.includes('FOV') || 
                               entityName.includes('Celestial') || 
                               entityName.includes('Footprint') ||
                               /\(FOV:.*¬∞\)/.test(entityName); // Match "(FOV: XX¬∞)" pattern
        
        if (isSensorEntity) {
          // Add a small delay before showing tooltip (prevents flickering when moving quickly)
          hoverTimeout = setTimeout(() => {
            setHoveredEntityName(entityName);
            setTooltipPosition({ x: movement.endPosition.x, y: movement.endPosition.y });
          }, 300); // 300ms delay
        } else {
          setHoveredEntityName(null);
          setTooltipPosition(null);
        }
      } else {
        setHoveredEntityName(null);
        setTooltipPosition(null);
      }
    }, ScreenSpaceEventType.MOUSE_MOVE);
    
    return () => {
      if (hoverTimeout) {
        clearTimeout(hoverTimeout);
      }
      handler.destroy();
    };
  }, [viewerRef, isLoaded]);

  useEffect(() => {
    const timeInterval = new TimeInterval({
      start: JulianDate.fromDate(timeRange.from.toDate()),
      stop: JulianDate.addDays(JulianDate.fromDate(timeRange.to.toDate()), 1, new JulianDate()),
    });

    // https://community.cesium.com/t/correct-way-to-wait-for-transform-to-be-ready/24800
    Transforms.preloadIcrfFixed(timeInterval).then(() => setLoaded(true));
  }, [timeRange]);

  // Parse satellite data from DataFrames
  // Main data parsing: extract satellite position, orientation, availability, and sensors
  // Note: parseSatellites() only uses options.coordinatesType internally, but we pass full options object for type compatibility
  useEffect(() => {
    if (!isLoaded) {
      return;
    }

    if (data.series.length > 0) {
      console.log(`üõ∞Ô∏è Parsing ${data.series.length} satellite(s)...`);
      
      try {
        const parsedSatellites = parseSatellites(data.series, options);
        setSatellites(parsedSatellites);
        
        // Parse ground stations
        const parsedGroundStations = parseGroundStations(data);
        setGroundStations(parsedGroundStations);
        console.log(`üì° Parsed ${parsedGroundStations.length} ground station(s)`);
        
        // Set timestamp from first satellite's first data point
        if (parsedSatellites.length > 0) {
          const firstSatellite = parsedSatellites[0];
          const firstInterval = firstSatellite.availability.get(0);
          if (firstInterval) {
            setTimestamp(firstInterval.start);
          }
        }
      } catch (error) {
        console.error('‚ùå Failed to parse satellites:', error);
        setSatellites([]);
        setGroundStations([]);
      }
    } else {
      setSatellites([]);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [data, options.coordinatesType, isLoaded]); // Only coordinatesType affects parsing; other options are for rendering only
  
  // Default to tracking first satellite
  useEffect(() => {
    if (satellites.length > 0 && !trackedSatelliteId) {
      setTrackedSatelliteId(satellites[0].id);
      console.log(`üéØ Defaulting to track: ${satellites[0].name}`);
    }
  }, [satellites, trackedSatelliteId]);

  useEffect(() => {
    Ion.defaultAccessToken = options.accessToken;
  }, [options.accessToken]);
  
  // Close dropdowns when clicking outside
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      const target = event.target as HTMLElement;
      if (!target.closest(`.${styles.topLeftControlsContainer}`)) {
        setIsModeDropdownOpen(false);
        setIsCameraDropdownOpen(false);
        setIsAxesDropdownOpen(false);
      }
    };
    
    if (isModeDropdownOpen || isCameraDropdownOpen || isAxesDropdownOpen) {
      document.addEventListener('mousedown', handleClickOutside);
      return () => document.removeEventListener('mousedown', handleClickOutside);
    }
    
    return undefined;
  }, [isModeDropdownOpen, isCameraDropdownOpen, isAxesDropdownOpen, styles.topLeftControlsContainer]);

  // Satellite visibility toggle functions
  const toggleSatelliteVisibility = (satelliteId: string) => {
    setHiddenSatellites(prev => {
      const next = new Set(prev);
      if (next.has(satelliteId)) {
        next.delete(satelliteId);
        console.log(`üëÅÔ∏è Showing satellite: ${satelliteId}`);
      } else {
        next.add(satelliteId);
        console.log(`üôà Hiding satellite: ${satelliteId}`);
      }
      return next;
    });
  };

  const isSatelliteVisible = (satelliteId: string) => {
    return !hiddenSatellites.has(satelliteId);
  };

  // Handle satellite selection for tracking
  const handleSatelliteClick = (satelliteId: string) => {
    if (isTracked) {
      // Tracked mode: just change the tracked satellite
      setTrackedSatelliteId(satelliteId);
      console.log(`üéØ Tracking switched to: ${satelliteId}`);
    } else {
      // Free mode: update tracked satellite, fly to nadir with zoom limit respected (2x Earth radius)
      setTrackedSatelliteId(satelliteId);
      const earthRadius = 6378137; // meters
      const safeDistance = earthRadius * 2; // ~12,756 km (within 3x limit)
      flyToSatelliteNadirView(satelliteId, 0.5, safeDistance);
      console.log(`üåç Free camera flying to: ${satelliteId}`);
    }
  };

  useEffect(() => {
    if (options.modelAssetId) {
      IonResource.fromAssetId(options.modelAssetId, { accessToken: options.accessToken })
        .then((resource) => {
          setSatelliteResource(resource);
        })
        .catch((error) => {
          throw new Error(`Error loading Ion Resource of Model: [${error}].`);
        });
    } else if (options.modelAssetUri) {
      setSatelliteResource(options.modelAssetUri);
    } else {
      setSatelliteResource(undefined);
    }
  }, [options.modelAssetId, options.modelAssetUri, options.accessToken]);

  // Only remount Viewer when options that affect the Viewer component itself change
  // Entity-level options (projections, trajectory, etc.) don't need a full remount
  useEffect(() => setViewerKey((prevKey) => prevKey + 1), [
    options.showAnimation,
    options.showTimeline,
    options.showInfoBox,
    options.showBaseLayerPicker,
    options.showSceneModePicker,
    options.showProjectionPicker,
    options.accessToken,
  ]);

  // Generate RA/Dec celestial grid
  useEffect(() => {
    if (!options.showRADecGrid || !timestamp) {
      setRALines([]);
      setDecLines([]);
      setGridLabels([]);
      return;
    }

    const celestialRadius = Ellipsoid.WGS84.maximumRadius * 100; // 100x Earth radius

    const { raLines, decLines } = generateRADecGrid({
      raSpacing: options.raSpacing,
      decSpacing: options.decSpacing,
      celestialRadius,
      referenceTime: timestamp,
    });

    setRALines(raLines);
    setDecLines(decLines);

    // Generate labels if enabled
    if (options.showGridLabels) {
      const labels = generateRADecGridLabels({
        raSpacing: options.raSpacing,
        decSpacing: options.decSpacing,
        celestialRadius,
        referenceTime: timestamp,
      });
      setGridLabels(labels);
    } else {
      setGridLabels([]);
    }
  }, [options.showRADecGrid, options.raSpacing, options.decSpacing, options.showGridLabels, timestamp]);

  // Setup default imagery once when Viewer is created (for persistence)
  useEffect(() => {
    // Only run if viewer exists (guard against race conditions)
    if (!viewerRef.current?.cesiumElement) {
      return;
    }
    
    const viewer = viewerRef.current.cesiumElement;
    const imageryLayers = viewer.imageryLayers;
    
    // Remove default imagery
    if (imageryLayers.length > 0) {
      imageryLayers.removeAll();
    }
    
    // Set default to Carto Dark Matter (no labels)
    const cartoNoLabelsProvider = new UrlTemplateImageryProvider({
      url: 'https://cartodb-basemaps-a.global.ssl.fastly.net/dark_nolabels/{z}/{x}/{y}.png',
      credit: 'Map tiles by Carto, under CC BY 3.0. Data by OpenStreetMap, under ODbL.',
    });
    imageryLayers.addImageryProvider(cartoNoLabelsProvider);
  }, [viewerKey]); // Run when Viewer is created/remounted

  useEffect(() => {
    if (!options.subscribeToDataHoverEvent) {
      return;
    }

    const dataHoverSubscriber = eventBus.getStream(DataHoverEvent).subscribe((event) => {
      if (event?.payload?.point?.time) {
        setTimestamp(JulianDate.fromDate(new Date(event.payload.point.time)));
      }
    });

    const graphHoverSubscriber = eventBus.getStream(LegacyGraphHoverEvent).subscribe((event) => {
      if (event?.payload?.point?.time) {
        setTimestamp(JulianDate.fromDate(new Date(event.payload.point.time)));
      }
    });

    return () => {
      dataHoverSubscriber.unsubscribe();
      graphHoverSubscriber.unsubscribe();
    };
  }, [eventBus, options.subscribeToDataHoverEvent]);

  return (
    <div
      className={cx(
        styles.wrapper,
        css`
          width: ${width}px;
          height: ${height}px;
        `
      )}
    >
      <div className={styles.panelContainer}>
        {/* Main content area - shrinks when sidebar opens */}
        <div className={cx(styles.mainContent, styles.cesiumControls)}>
          {/* Top-Left Control Panel - Mode & Camera Dropdowns */}
          <div className={styles.topLeftControlsContainer}>
            {/* Mode Dropdown */}
            <div style={{ position: 'relative' }}>
              <button
                className={styles.dropdownButton}
                onClick={() => {
                  setIsModeDropdownOpen(!isModeDropdownOpen);
                  setIsCameraDropdownOpen(false);
                }}
                title="View Mode"
              >
                Mode
                <ChevronDown size={16} />
              </button>
              
              {isModeDropdownOpen && (
                <div className={styles.dropdownMenu}>
                  <div
                    className={`${styles.dropdownItem} ${selectedMode === 'satellite' ? 'active' : ''}`}
                    onClick={() => {
                      setSelectedMode('satellite');
                      setIsModeDropdownOpen(false);
                      // TODO: Implement satellite-centered view logic
                    }}
                  >
                    <span className={styles.dropdownItemLabel}>üõ∞Ô∏è Satellite Focus</span>
                    <span className={styles.dropdownItemDescription}>Center on tracked satellite</span>
                  </div>
                  <div
                    className={`${styles.dropdownItem} ${selectedMode === 'earth' ? 'active' : ''}`}
                    onClick={() => {
                      setSelectedMode('earth');
                      setIsModeDropdownOpen(false);
                      // TODO: Implement earth-centered view logic
                    }}
                  >
                    <span className={styles.dropdownItemLabel}>üåç Earth Focus</span>
                    <span className={styles.dropdownItemDescription}>Center on Earth</span>
                  </div>
                  <div
                    className={`${styles.dropdownItem} ${selectedMode === 'celestial' ? 'active' : ''}`}
                    onClick={() => {
                      setSelectedMode('celestial');
                      setIsModeDropdownOpen(false);
                      // TODO: Implement celestial map view logic
                    }}
                  >
                    <span className={styles.dropdownItemLabel}>‚≠ê Celestial Map</span>
                    <span className={styles.dropdownItemDescription}>RA/Dec reference frame</span>
                  </div>
                </div>
              )}
            </div>
            
            {/* Camera Angle Dropdown - Options change based on selected mode */}
            <div style={{ position: 'relative' }}>
              <button
                className={styles.dropdownButton}
                onClick={() => {
                  setIsCameraDropdownOpen(!isCameraDropdownOpen);
                  setIsModeDropdownOpen(false);
                }}
                title="Camera View"
              >
                <Video size={16} />
                <ChevronDown size={16} />
              </button>
              
              {isCameraDropdownOpen && (
                <div className={styles.dropdownMenu}>
                  {/* Satellite Focus Mode - Satellite-centric camera views */}
                  {selectedMode === 'satellite' && (
                    <>
                      <div
                        className={`${styles.dropdownItem} ${satelliteCameraView === 'nadir' ? 'active' : ''}`}
                        onClick={() => {
                          setSatelliteCameraView('nadir');
                          setIsCameraDropdownOpen(false);
                          // Use existing nadir view function
                          if (trackedSatelliteId) {
                            flyToSatelliteNadirView(trackedSatelliteId);
                          }
                        }}
                      >
                        <span className={styles.dropdownItemLabel}>üî≠ Nadir View</span>
                        <span className={styles.dropdownItemDescription}>View from directly above</span>
                      </div>
                      <div
                        className={`${styles.dropdownItem} ${satelliteCameraView === 'lvlh' ? 'active' : ''}`}
                        onClick={() => {
                          setSatelliteCameraView('lvlh');
                          setIsCameraDropdownOpen(false);
                          // TODO: Implement LVLH view
                        }}
                      >
                        <span className={styles.dropdownItemLabel}>üìê LVLH View</span>
                        <span className={styles.dropdownItemDescription}>Local vertical/horizontal frame</span>
                      </div>
                      <div
                        className={`${styles.dropdownItem} ${satelliteCameraView === 'fixed' ? 'active' : ''}`}
                        onClick={() => {
                          setSatelliteCameraView('fixed');
                          setIsCameraDropdownOpen(false);
                          // TODO: Implement fixed inertial view
                        }}
                      >
                        <span className={styles.dropdownItemLabel}>üß≠ Fixed Inertial</span>
                        <span className={styles.dropdownItemDescription}>Inertial reference frame</span>
                      </div>
                      <div
                        className={`${styles.dropdownItem} ${satelliteCameraView === 'free' ? 'active' : ''}`}
                        onClick={() => {
                          setSatelliteCameraView('free');
                          setIsCameraDropdownOpen(false);
                          // TODO: Implement free camera mode
                        }}
                      >
                        <span className={styles.dropdownItemLabel}>üéÆ Free Camera</span>
                        <span className={styles.dropdownItemDescription}>Manual camera control</span>
                      </div>
                    </>
                  )}
                  
                  {/* Celestial Map Mode - Celestial reference pointing */}
                  {selectedMode === 'celestial' && (
                    <>
                      <div
                        className={`${styles.dropdownItem} ${celestialCameraView === 'sun' ? 'active' : ''}`}
                        onClick={() => {
                          setCelestialCameraView('sun');
                          setIsCameraDropdownOpen(false);
                          // TODO: Implement sun pointing
                        }}
                      >
                        <span className={styles.dropdownItemLabel}>‚òÄÔ∏è Sun Pointing</span>
                        <span className={styles.dropdownItemDescription}>Camera points toward sun</span>
                      </div>
                      <div
                        className={`${styles.dropdownItem} ${celestialCameraView === 'lvlh-orbit' ? 'active' : ''}`}
                        onClick={() => {
                          setCelestialCameraView('lvlh-orbit');
                          setIsCameraDropdownOpen(false);
                          // TODO: Implement LVLH orbit direction pointing
                        }}
                      >
                        <span className={styles.dropdownItemLabel}>üõ∞Ô∏è LVLH Orbit Direction</span>
                        <span className={styles.dropdownItemDescription}>Aligned with orbit velocity</span>
                      </div>
                      <div
                        className={`${styles.dropdownItem} ${celestialCameraView === 'star' ? 'active' : ''}`}
                        onClick={() => {
                          setCelestialCameraView('star');
                          setIsCameraDropdownOpen(false);
                          // TODO: Implement star pointing
                        }}
                      >
                        <span className={styles.dropdownItemLabel}>‚≠ê Star Pointing</span>
                        <span className={styles.dropdownItemDescription}>Fixed stellar reference</span>
                      </div>
                      <div
                        className={`${styles.dropdownItem} ${celestialCameraView === 'groundstation' ? 'active' : ''}`}
                        onClick={() => {
                          setCelestialCameraView('groundstation');
                          setIsCameraDropdownOpen(false);
                          // TODO: Implement ground station pointing
                        }}
                      >
                        <span className={styles.dropdownItemLabel}>üì° Ground Station Pointing</span>
                        <span className={styles.dropdownItemDescription}>Camera toward selected station</span>
                      </div>
                    </>
                  )}
                  
                  {/* Earth Focus Mode - Reference frame selection */}
                  {selectedMode === 'earth' && (
                    <>
                      <div
                        className={`${styles.dropdownItem} ${earthCameraView === 'icrf' ? 'active' : ''}`}
                        onClick={() => {
                          setEarthCameraView('icrf');
                          setIsCameraDropdownOpen(false);
                          // TODO: Implement ICRF frame
                        }}
                      >
                        <span className={styles.dropdownItemLabel}>üåå ICRF</span>
                        <span className={styles.dropdownItemDescription}>International Celestial Reference Frame</span>
                      </div>
                      <div
                        className={`${styles.dropdownItem} ${earthCameraView === 'itrf' ? 'active' : ''}`}
                        onClick={() => {
                          setEarthCameraView('itrf');
                          setIsCameraDropdownOpen(false);
                          // TODO: Implement ITRF frame
                        }}
                      >
                        <span className={styles.dropdownItemLabel}>üåç ITRF</span>
                        <span className={styles.dropdownItemDescription}>International Terrestrial Reference Frame</span>
                      </div>
                      <div
                        className={`${styles.dropdownItem} ${earthCameraView === 'gcrf' ? 'active' : ''}`}
                        onClick={() => {
                          setEarthCameraView('gcrf');
                          setIsCameraDropdownOpen(false);
                          // TODO: Implement GCRF frame
                        }}
                      >
                        <span className={styles.dropdownItemLabel}>üî≠ GCRF</span>
                        <span className={styles.dropdownItemDescription}>Geocentric Celestial Reference Frame</span>
                      </div>
                      <div
                        className={`${styles.dropdownItem} ${earthCameraView === 'teme' ? 'active' : ''}`}
                        onClick={() => {
                          setEarthCameraView('teme');
                          setIsCameraDropdownOpen(false);
                          // TODO: Implement TEME frame
                        }}
                      >
                        <span className={styles.dropdownItemLabel}>üõ∞Ô∏è TEME</span>
                        <span className={styles.dropdownItemDescription}>True Equator Mean Equinox</span>
                      </div>
                    </>
                  )}
                </div>
              )}
            </div>
            
            {/* Reference Axes Visibility Toggle - Common to All Modes */}
            <div style={{ position: 'relative' }}>
              <button
                className={styles.dropdownButton}
                onClick={() => {
                  setIsAxesDropdownOpen(!isAxesDropdownOpen);
                  setIsModeDropdownOpen(false);
                  setIsCameraDropdownOpen(false);
                }}
                title="Select visible reference axes"
              >
                <Move3d size={16} />
                <ChevronDown size={16} />
              </button>
              
              {isAxesDropdownOpen && (
                <div className={styles.dropdownMenu}>
                  {/* LVLH Reference Frame Toggle */}
                  <div 
                    className={styles.toggleItem}
                    onClick={() => setShowLVLHAxes(!showLVLHAxes)}
                    style={{ cursor: 'pointer' }}
                  >
                    <span className={styles.toggleLabel}>
                      LVLH Reference Frame
                    </span>
                    {showLVLHAxes ? <Eye size={18} /> : <EyeOff size={18} />}
                  </div>
                  
                  {/* Body Axes Reference Frame Toggle */}
                  <div 
                    className={styles.toggleItem}
                    onClick={() => setShowBodyAxes(!showBodyAxes)}
                    style={{ cursor: 'pointer' }}
                  >
                    <span className={styles.toggleLabel}>
                      Body Axes Reference Frame
                    </span>
                    {showBodyAxes ? <Eye size={18} /> : <EyeOff size={18} />}
                  </div>
                  
                  {/* ITRF Reference Frame Toggle */}
                  <div 
                    className={styles.toggleItem}
                    onClick={() => setShowITRFAxes(!showITRFAxes)}
                    style={{ cursor: 'pointer' }}
                  >
                    <span className={styles.toggleLabel}>
                      ITRF Reference Frame
                    </span>
                    {showITRFAxes ? <Eye size={18} /> : <EyeOff size={18} />}
                  </div>
                  
                  {/* ICRF Reference Frame Toggle */}
                  <div 
                    className={styles.toggleItem}
                    onClick={() => setShowICRFAxes(!showICRFAxes)}
                    style={{ cursor: 'pointer' }}
                  >
                    <span className={styles.toggleLabel}>
                      ICRF Reference Frame
                    </span>
                    {showICRFAxes ? <Eye size={18} /> : <EyeOff size={18} />}
                  </div>
                </div>
              )}
            </div>
          </div>
          
          {/* Sidebar Toggle Button */}
          <button
            className={styles.sidebarToggle}
            onClick={() => setIsSidebarOpen(!isSidebarOpen)}
            title={isSidebarOpen ? 'Close sidebar' : 'Open sidebar'}
          >
            {isSidebarOpen ? <ChevronRight size={20} /> : <Menu size={20} />}
          </button>
      
          <Viewer
        full
        animation={options.showAnimation}
        timeline={options.showTimeline}
        infoBox={options.showInfoBox}
        baseLayerPicker={options.showBaseLayerPicker}
        sceneModePicker={options.showSceneModePicker}
        projectionPicker={options.showProjectionPicker}
        navigationHelpButton={false}
        fullscreenButton={false}
        geocoder={false}
        homeButton={false}
        key={viewerKey}
        creditContainer="cesium-credits"
        ref={(ref) => {
          // Store ref for use in useEffect (imagery setup)
          viewerRef.current = ref;
          
          if (ref?.cesiumElement) {
            const viewer = ref.cesiumElement;
            const controller = viewer.scene.screenSpaceCameraController;
            const camera = viewer.scene.camera;
            
            // WGS84 Earth radius
            const earthRadius = 6378137; // meters
            
            // Controller limit: 3x Earth radius (works smoothly for tracked mode)
            controller.maximumZoomDistance = earthRadius * 3; // ~19,134 km
            controller.enableCollisionDetection = false;
            
            // Hard camera height limit: 5x Earth radius (catches free camera mode)
            // const hardMaxZoomDistance = earthRadius * 5; // ~31,890 km
            
            
            
            // Extend camera far clipping plane for celestial grid visibility
            const celestialDistance = earthRadius * 100;
            camera.frustum.far = celestialDistance * 3;
            
            // Add Carto options to BaseLayerPicker (runs in ref callback for guaranteed timing)
            // Note: Default imagery setup is in useEffect to prevent reset on re-renders
            if (viewer.baseLayerPicker) {
              const vm = viewer.baseLayerPicker.viewModel;
              
              // Check if already added (avoid duplicates)
              const hasCartoNoLabels = vm.imageryProviderViewModels.some((p: any) => p.name === 'Carto Dark Matter (No Labels)');
              
              if (!hasCartoNoLabels) {
                // Find Stadia Dark icon to reuse
                const stadiaViewModel = vm.imageryProviderViewModels.find(
                  (p: any) => p.name === 'Stadia Alidade Smooth Dark'
                );
                const darkIconUrl = stadiaViewModel?.iconUrl || buildModuleUrl('Widgets/Images/ImageryProviders/openStreetMap.png');
                
                // Create Carto Dark Matter (No Labels) option
                const cartoNoLabelsViewModel = new ProviderViewModel({
                  name: 'Carto Dark Matter (No Labels)',
                  iconUrl: darkIconUrl,
                  tooltip: 'Dark theme map without city/country labels - clean view with borders only',
                  creationFunction: () => new UrlTemplateImageryProvider({
                    url: 'https://cartodb-basemaps-a.global.ssl.fastly.net/dark_nolabels/{z}/{x}/{y}.png',
                    credit: 'Map tiles by Carto, under CC BY 3.0. Data by OpenStreetMap, under ODbL.',
                  }),
                });
                
                // Create Carto Dark Matter (With Labels) option
                const cartoWithLabelsViewModel = new ProviderViewModel({
                  name: 'Carto Dark Matter (With Labels)',
                  iconUrl: darkIconUrl,
                  tooltip: 'Dark theme map with city/country labels',
                  creationFunction: () => new UrlTemplateImageryProvider({
                    url: 'https://cartodb-basemaps-a.global.ssl.fastly.net/dark_all/{z}/{x}/{y}.png',
                    credit: 'Map tiles by Carto, under CC BY 3.0. Data by OpenStreetMap, under ODbL.',
                  }),
                });
                
                // Add both options to the picker
                vm.imageryProviderViewModels.push(cartoNoLabelsViewModel, cartoWithLabelsViewModel);
                
                // Set the selected imagery to Carto Dark Matter (No Labels) - only on first add
                const cartoNoLabelsVM = vm.imageryProviderViewModels.find(
                  (p: any) => p.name === 'Carto Dark Matter (No Labels)'
                );
                
                if (cartoNoLabelsVM) {
                  vm.selectedImagery = cartoNoLabelsVM;
                }
              }
            }
          }
        }}
      >
        {timestamp && <Clock currentTime={timestamp} />}
        
        {/* Main Satellite Entities - Multiple satellites support */}
        {/* Main Satellite Entities - Hidden in Celestial Map mode */}
        {selectedMode !== 'celestial' && satellites
          .filter(sat => !hiddenSatellites.has(sat.id))
          .map((satellite) => {
            const isThisSatelliteTracked = isTracked && trackedSatelliteId === satellite.id;
            return (
              <SatelliteEntityRenderer
                key={satellite.id}
                satellite={satellite}
                options={options}
                satelliteResource={satelliteResource}
                isTracked={isThisSatelliteTracked}
              />
            );
          })
        }
        
        {/* Visible tracking entity for Celestial Map mode */}
        {/* Provides a tracking anchor point at satellite position when satellite model is hidden */}
        {selectedMode === 'celestial' && satellites
          .filter(sat => !hiddenSatellites.has(sat.id))
          .map((satellite) => {
            const isThisSatelliteTracked = isTracked && trackedSatelliteId === satellite.id;
            return (
              <Entity
                key={`${satellite.id}-celestial-tracker`}
                id={satellite.id} // Use same ID as satellite for proper tracking
                name={`${satellite.name} (Celestial Tracking)`}
                position={satellite.position}
                orientation={satellite.orientation}
                availability={satellite.availability}
                tracked={isThisSatelliteTracked}
              >
                {/* Visible marker for debugging tracking */}
                <PointGraphics 
                  pixelSize={15}
                  color={Color.YELLOW}
                  outlineColor={Color.BLACK}
                  outlineWidth={2}
                />
                <LabelGraphics
                  text={satellite.name}
                  font="14px sans-serif"
                  fillColor={Color.WHITE}
                  outlineColor={Color.BLACK}
                  outlineWidth={2}
                  style={LabelStyle.FILL_AND_OUTLINE}
                  pixelOffset={new Cartesian2(0, -20)}
                />
              </Entity>
            );
          })
        }
        {/* Body Axes (X/Y/Z attitude vectors) - Per-satellite - Hidden in Celestial Map mode */}
        {selectedMode !== 'celestial' && options.showAttitudeVisualization && options.showBodyAxes && satellites
          .filter(sat => !hiddenSatellites.has(sat.id))
          .map((satellite) => {
            const isThisSatelliteTracked = isTracked && trackedSatelliteId === satellite.id;
            return (
              <BodyAxesRenderer
                key={`${satellite.id}-body-axes`}
                satellite={satellite}
                options={options}
                isTracked={isThisSatelliteTracked}
                viewerRef={viewerRef}
                attitudeVectors={attitudeVectors}
              />
            );
          })
        }
        
        {/* Sensor Visualization (Cones, Footprints, Celestial Projections) */}
        {/* In Celestial Map mode: hide cones, show only footprints and celestial projections */}
        {options.showAttitudeVisualization && satellites
          .filter(sat => !hiddenSatellites.has(sat.id))
          .map((satellite) => {
            const isThisSatelliteTracked = isTracked && trackedSatelliteId === satellite.id;
            return satellite.sensors.map((sensor, idx) => {
              // Get the actual color for this sensor (respecting user overrides)
              const sensorColor = _getSensorColor(satellite.id, sensor.id, sensor, idx);
              
              // Override options for Celestial Map mode: hide sensor cones
              const effectiveOptions = selectedMode === 'celestial' 
                ? { ...options, showSensorCones: false }
                : options;
              
              return (
                <SensorVisualizationRenderer
                  key={`${satellite.id}-sensor-${sensor.id}`}
                  satellite={satellite}
                  sensor={sensor}
                  options={effectiveOptions}
                  isTracked={isThisSatelliteTracked}
                  viewerRef={viewerRef}
                  sensorIndex={idx}
                  transparentMode={satelliteRenderSettings.get(satellite.id)?.transparentCones || false}
                  customColor={sensorColor}
                />
              );
            });
          })
        }
        
        {/* Uncertainty Ellipsoids - Per-satellite - Hidden in Celestial Map mode */}
        {selectedMode !== 'celestial' && options.showAttitudeVisualization && options.showUncertaintyEllipsoids && satellites
          .filter(sat => !hiddenSatellites.has(sat.id))
          .filter(sat => satelliteRenderSettings.get(sat.id)?.showEllipsoid !== false)
          .map((satellite) => {
            // Only render if satellite has covariance data
            if (!satellite.covariance || satellite.covariance.length === 0) {
              return null;
            }
            
            return (
              <UncertaintyEllipsoidRenderer
                key={`${satellite.id}-uncertainty`}
                satellite={satellite}
                opacityMode={options.uncertaintyOpacityMode}
                ellipsoidColor={options.uncertaintyColor}
                sigmaScale={1.0}
              />
            );
          })
        }
        
        {/* RA/Dec Celestial Grid */}
        {options.showAttitudeVisualization && options.showRADecGrid && (
          <CelestialGridRenderer
            options={options}
            raLines={raLines}
            decLines={decLines}
            gridLabels={gridLabels}
          />
        )}
        
        {/* Celestial Bodies (Sun + Earth Center) */}
        <CelestialBodiesRenderer
          options={options}
          viewerRef={viewerRef}
        />
        {options.locations.map((location, index) => (
          <Entity
            name={location.name}
            position={Cartesian3.fromDegrees(location.longitude, location.latitude, location.altitude)}
            key={index}
          >
            <PointGraphics
              pixelSize={options.locationPointSize}
              color={Color.fromCssColorString(options.locationPointColor)}
            />
            <LabelGraphics text={location.name} pixelOffset={new Cartesian2(30.0, 30.0)} />
          </Entity>
        ))}

        {/* Ground Stations */}
        {groundStations
          .filter(gs => !hiddenGroundStations.has(gs.id))
          .map((gs) => (
            <GroundStationRenderer key={gs.id} groundStation={gs} />
          ))
        }
      </Viewer>

          <div
            id="cesium-credits"
            className={options.showCredits ? styles.showCesiumCredits : styles.hideCesiumCredits}
          ></div>
          
          {/* Compact Legend Panel - Bottom Right */}
          <div className={`${styles.legendPanel} ${isLegendCollapsed ? 'collapsed' : ''}`}>
            <div 
              className={styles.legendHeader}
              onClick={() => setIsLegendCollapsed(!isLegendCollapsed)}
              title={isLegendCollapsed ? 'Expand legend' : 'Collapse legend'}
            >
              <span>Legend</span>
              <button className={styles.legendToggleButton}>
                {isLegendCollapsed ? <ChevronUp size={14} /> : <ChevronDown size={14} />}
              </button>
            </div>
            {!isLegendCollapsed && (
              <div className={styles.legendContent}>
              {/* Reference Frames Section */}
              <div className={styles.legendSection}>
                <div className={styles.legendSectionTitle}>Reference Frames</div>
                
                {/* LVLH Frame (placeholder) */}
                {showLVLHAxes && (
                  <div className={styles.legendItem}>
                    <div
                      className={styles.legendColorSwatch}
                      style={{ background: '#FFA500' }}
                      onClick={() => setExpandedLegendItem(expandedLegendItem === 'lvlh' ? null : 'lvlh')}
                    />
                    <span className={styles.legendItemName}>LVLH Frame</span>
                  </div>
                )}
                {expandedLegendItem === 'lvlh' && (
                  <div className={styles.legendColorPicker}>
                    {/* Placeholder for color picker */}
                    <div style={{ fontSize: '10px', color: 'rgba(255,255,255,0.5)' }}>Color picker here</div>
                  </div>
                )}
                
                {/* Body Axes Frame (placeholder) */}
                {showBodyAxes && (
                  <div className={styles.legendItem}>
                    <div
                      className={styles.legendColorSwatch}
                      style={{ background: '#FF0000' }}
                      onClick={() => setExpandedLegendItem(expandedLegendItem === 'body' ? null : 'body')}
                    />
                    <span className={styles.legendItemName}>Body Axes</span>
                  </div>
                )}
                {expandedLegendItem === 'body' && (
                  <div className={styles.legendColorPicker}>
                    <div style={{ fontSize: '10px', color: 'rgba(255,255,255,0.5)' }}>Color picker here</div>
                  </div>
                )}
                
                {/* ITRF Frame (placeholder) */}
                {showITRFAxes && (
                  <div className={styles.legendItem}>
                    <div
                      className={styles.legendColorSwatch}
                      style={{ background: '#00FF00' }}
                      onClick={() => setExpandedLegendItem(expandedLegendItem === 'itrf' ? null : 'itrf')}
                    />
                    <span className={styles.legendItemName}>ITRF Frame</span>
                  </div>
                )}
                {expandedLegendItem === 'itrf' && (
                  <div className={styles.legendColorPicker}>
                    <div style={{ fontSize: '10px', color: 'rgba(255,255,255,0.5)' }}>Color picker here</div>
                  </div>
                )}
                
                {/* ICRF Frame (placeholder) */}
                {showICRFAxes && (
                  <div className={styles.legendItem}>
                    <div
                      className={styles.legendColorSwatch}
                      style={{ background: '#0000FF' }}
                      onClick={() => setExpandedLegendItem(expandedLegendItem === 'icrf' ? null : 'icrf')}
                    />
                    <span className={styles.legendItemName}>ICRF Frame</span>
                  </div>
                )}
                {expandedLegendItem === 'icrf' && (
                  <div className={styles.legendColorPicker}>
                    <div style={{ fontSize: '10px', color: 'rgba(255,255,255,0.5)' }}>Color picker here</div>
                  </div>
                )}
              </div>
              
              {/* Sensors Section (placeholder for selected satellite) */}
              <div className={styles.legendSection}>
                <div className={styles.legendSectionTitle}>Sensors (Satellite 1)</div>
                
                {/* Sample sensors - replace with real data later */}
                <div className={styles.legendItem}>
                  <div
                    className={styles.legendColorSwatch}
                    style={{ background: '#FF1493' }}
                    onClick={() => setExpandedLegendItem(expandedLegendItem === 'sensor1' ? null : 'sensor1')}
                  />
                  <span className={styles.legendItemName}>Main Camera</span>
                </div>
                {expandedLegendItem === 'sensor1' && (
                  <div className={styles.legendColorPicker}>
                    <div style={{ fontSize: '10px', color: 'rgba(255,255,255,0.5)' }}>Color picker here</div>
                  </div>
                )}
                
                <div className={styles.legendItem}>
                  <div
                    className={styles.legendColorSwatch}
                    style={{ background: '#00CED1' }}
                    onClick={() => setExpandedLegendItem(expandedLegendItem === 'sensor2' ? null : 'sensor2')}
                  />
                  <span className={styles.legendItemName}>Star Tracker</span>
                </div>
                {expandedLegendItem === 'sensor2' && (
                  <div className={styles.legendColorPicker}>
                    <div style={{ fontSize: '10px', color: 'rgba(255,255,255,0.5)' }}>Color picker here</div>
                  </div>
                )}
                
                <div className={styles.legendItem}>
                  <div
                    className={styles.legendColorSwatch}
                    style={{ background: '#FFD700' }}
                    onClick={() => setExpandedLegendItem(expandedLegendItem === 'sensor3' ? null : 'sensor3')}
                  />
                  <span className={styles.legendItemName}>Antenna</span>
                </div>
                {expandedLegendItem === 'sensor3' && (
                  <div className={styles.legendColorPicker}>
                    <div style={{ fontSize: '10px', color: 'rgba(255,255,255,0.5)' }}>Color picker here</div>
                  </div>
                )}
              </div>
            </div>
            )}
          </div>
        </div>

        {/* Sidebar - Satellite & Ground Station Lists */}
        <div className={cx(styles.sidebar, isSidebarOpen && 'open')}>
          <div className={styles.sidebarContent}>
            {/* Tab Navigation */}
            <div className={styles.tabContainer}>
              <button
                className={cx(styles.tab, activeTab === 'satellites' && 'active')}
                onClick={() => setActiveTab('satellites')}
              >
                Satellites
              </button>
              <button
                className={cx(styles.tab, activeTab === 'groundstations' && 'active')}
                onClick={() => setActiveTab('groundstations')}
              >
                Ground Stations
              </button>
            </div>

            {/* Satellites Tab Content */}
            {activeTab === 'satellites' && (
              <>
                {satellites.length === 0 ? (
                  <div className={styles.emptyState}>No satellites available</div>
                ) : (
                  <div className={styles.satelliteList}>
                    {satellites.map((satellite) => (
                      <div 
                        key={satellite.id} 
                        className={cx(
                          styles.satelliteItem,
                          trackedSatelliteId === satellite.id && 'tracked'
                        )}
                        onClick={() => handleSatelliteClick(satellite.id)}
                      >
                        <button
                          className={styles.visibilityToggle}
                          onClick={(e) => {
                            e.stopPropagation();
                            toggleSatelliteVisibility(satellite.id);
                          }}
                          title={isSatelliteVisible(satellite.id) ? 'Hide satellite' : 'Show satellite'}
                        >
                          {isSatelliteVisible(satellite.id) ? <Eye size={16} /> : <EyeOff size={16} />}
                        </button>
                        
                        <div className={styles.satelliteInfo}>
                          <div className={styles.satelliteName} title={satellite.name}>
                            {satellite.name}
                          </div>
                          <div className={styles.satelliteId} title={satellite.id}>
                            {satellite.id}
                          </div>
                        </div>
                        
                        <button
                          className={styles.settingsButton}
                          onClick={(e) => {
                            e.stopPropagation();
                            setSettingsModalSatelliteId(satellite.id);
                          }}
                          title="Satellite settings"
                        >
                          <Settings size={16} />
                        </button>
                      </div>
                    ))}
                  </div>
                )}
              </>
            )}

            {/* Ground Stations Tab Content */}
            {activeTab === 'groundstations' && (
              <>
                {groundStations.length === 0 ? (
                  <div className={styles.emptyState}>No ground stations available</div>
                ) : (
                  <div className={styles.satelliteList}>
                    {groundStations.map((gs) => {
                      const isHidden = hiddenGroundStations.has(gs.id);
                      
                      return (
                        <div 
                          key={gs.id} 
                          className={styles.satelliteItem}
                        >
                          <button
                            className={styles.visibilityToggle}
                            onClick={(e) => {
                              e.stopPropagation();
                              const newHidden = new Set(hiddenGroundStations);
                              if (isHidden) {
                                newHidden.delete(gs.id);
                              } else {
                                newHidden.add(gs.id);
                              }
                              setHiddenGroundStations(newHidden);
                            }}
                            title={isHidden ? 'Show ground station' : 'Hide ground station'}
                          >
                            {isHidden ? <EyeOff size={16} /> : <Eye size={16} />}
                          </button>
                          
                          <div className={styles.satelliteInfo}>
                            <div className={styles.satelliteName} title={gs.name}>
                              {gs.name}
                            </div>
                            <div className={styles.satelliteId} title={gs.id}>
                              {gs.id}
                            </div>
                          </div>
                          
                          <button
                            className={styles.povButton}
                            onClick={(e) => {
                              e.stopPropagation();
                              // TODO: Implement POV functionality
                              console.log(`POV clicked for ground station: ${gs.name}`);
                            }}
                            title="Switch to ground station POV"
                          >
                            POV
                          </button>
                          
                          <button
                            className={styles.settingsButton}
                            onClick={(e) => {
                              e.stopPropagation();
                              setSettingsModalGroundStationId(gs.id);
                            }}
                            title="Ground station settings"
                          >
                            <Settings size={16} />
                          </button>
                        </div>
                      );
                    })}
                  </div>
                )}
              </>
            )}
          </div>
        </div>

        {/* Settings Modal */}
        {settingsModalSatelliteId && (
          <div 
            ref={satelliteModalRef}
            className={styles.modalOverlay}
            onClick={() => setSettingsModalSatelliteId(null)}
            onKeyDown={(e) => {
              if (e.key === 'Escape') {
                e.stopPropagation();  // Prevent Grafana from handling ESC
                e.preventDefault();    // Cancel default browser behavior
                setSettingsModalSatelliteId(null);  // Close modal
              }
            }}
            tabIndex={-1}  // Make div focusable to receive keyboard events
          >
            <div 
              className={styles.modal}
              onClick={(e) => e.stopPropagation()}
            >
              <div className={styles.modalHeader}>
                <h3 className={styles.modalTitle}>
                  <Settings size={18} />
                  {satellites.find(sat => sat.id === settingsModalSatelliteId)?.name || 'Satellite Settings'}
                </h3>
                <button
                  className={styles.modalClose}
                  onClick={() => setSettingsModalSatelliteId(null)}
                  title="Close"
                >
                  <X size={20} />
                </button>
              </div>
              <div className={styles.modalContent}>
                {/* Sensor Colors Section */}
                {(() => {
                  const currentSatellite = satellites.find(sat => sat.id === settingsModalSatelliteId);
                  const hasSensors = currentSatellite && currentSatellite.sensors.length > 0;
                  
                  return hasSensors ? (
                    <div className={styles.settingsGroup}>
                      <h4 className={styles.settingsGroupTitle}>Sensor Colors</h4>
                      {currentSatellite!.sensors.map((sensor, idx) => {
                        const color = _getSensorColor(currentSatellite!.id, sensor.id, sensor, idx);
                        
                        return (
                          <div key={sensor.id} className={styles.settingRow}>
                            <div className={styles.sensorColorRowVertical}>
                              <div className={styles.sensorNameRow}>
                                <div className={styles.sensorName}>{sensor.name}</div>
                                <button
                                  className={styles.resetButton}
                                  onClick={() => {
                                    _resetSensorColor(currentSatellite!.id, sensor.id);
                                  }}
                                  title="Reset to default color from JSON"
                                >
                                  Reset
                                </button>
                              </div>
                              <div className={styles.colorPickerWrapper}>
                                <ColorPicker
                                  color={color}
                                  onChange={(newColor) => {
                                    _updateSensorColor(currentSatellite!.id, sensor.id, newColor);
                                  }}
                                />
                              </div>
                            </div>
                          </div>
                        );
                      })}
                    </div>
                  ) : null;
                })()}

                {/* Render Settings Section */}
                <div className={styles.settingsGroup}>
                  <h4 className={styles.settingsGroupTitle}>Render Settings</h4>
                  
                {/* Setting 1: Transparent Sensor Cones (Functional) */}
                <div className={styles.settingRow}>
                  <div>
                    <label className={styles.settingLabel}>
                      <input
                        type="checkbox"
                        checked={satelliteRenderSettings.get(settingsModalSatelliteId!)?.transparentCones || false}
                        onChange={(e) => {
                          // Show warning when enabling transparent mode
                          if (e.target.checked) {
                            const confirmed = window.confirm(
                              '‚ö†Ô∏è Performance Warning\n\n' +
                              'Transparent sensor cones may significantly impact frame rate, ' +
                              'especially with multiple satellites and sensors.\n\n' +
                              'Lower frame rates are expected when this feature is enabled.\n\n' +
                              'Do you want to activate transparent cones?'
                            );
                            if (!confirmed) {
                              return; // User cancelled, don't change the setting
                            }
                          }
                          
                          const newSettings = new Map(satelliteRenderSettings);
                          const current = newSettings.get(settingsModalSatelliteId!) || {
                            transparentCones: false,
                            showEllipsoid: false,
                            setting2: false,
                            setting3: false,
                            setting4: false,
                            setting5: false,
                            setting6: false,
                            setting7: false,
                            setting8: false,
                            setting9: false,
                          };
                          newSettings.set(settingsModalSatelliteId!, {
                            ...current,
                            transparentCones: e.target.checked
                          });
                          setSatelliteRenderSettings(newSettings);
                        }}
                      />
                      <span>Transparent Sensor Cones</span>
                    </label>
                    <div className={styles.settingDescription}>
                      Show filled transparent cones instead of wireframe grid (‚ö†Ô∏è may impact performance)
                    </div>
                  </div>
                </div>

                {/* Setting 2: Show Uncertainty Ellipsoid */}
                <div className={styles.settingRow}>
                  <div>
                    <label className={styles.settingLabel}>
                      <input
                        type="checkbox"
                        checked={satelliteRenderSettings.get(settingsModalSatelliteId!)?.showEllipsoid || false}
                        onChange={(e) => {
                          const newSettings = new Map(satelliteRenderSettings);
                          const current = newSettings.get(settingsModalSatelliteId!) || {
                            transparentCones: false,
                            showEllipsoid: false,
                            setting2: false,
                            setting3: false,
                            setting4: false,
                            setting5: false,
                            setting6: false,
                            setting7: false,
                            setting8: false,
                            setting9: false,
                          };
                          newSettings.set(settingsModalSatelliteId!, {
                            ...current,
                            showEllipsoid: e.target.checked
                          });
                          setSatelliteRenderSettings(newSettings);
                        }}
                      />
                      <span>Show Uncertainty Ellipsoid</span>
                    </label>
                    <div className={styles.settingDescription}>
                      Display 3D confidence ellipsoid representing position uncertainty
                    </div>
                  </div>
                </div>
                </div> {/* End Render Settings Group */}
              </div>
            </div>
          </div>
        )}

        {/* Ground Station Settings Modal */}
        {settingsModalGroundStationId && (
          <div 
            ref={groundStationModalRef}
            className={styles.modalOverlay}
            onClick={() => setSettingsModalGroundStationId(null)}
            onKeyDown={(e) => {
              if (e.key === 'Escape') {
                e.stopPropagation();
                e.preventDefault();
                setSettingsModalGroundStationId(null);
              }
            }}
            tabIndex={-1}
          >
            <div 
              className={styles.modal}
              onClick={(e) => e.stopPropagation()}
            >
              <div className={styles.modalHeader}>
                <h3 className={styles.modalTitle}>
                  <Settings size={18} />
                  {groundStations.find(gs => gs.id === settingsModalGroundStationId)?.name || 'Ground Station Settings'}
                </h3>
                <button
                  className={styles.modalClose}
                  onClick={() => setSettingsModalGroundStationId(null)}
                  title="Close"
                >
                  <X size={20} />
                </button>
              </div>
              <div className={styles.modalContent}>
                <div className={styles.emptyState}>
                  Ground station settings coming soon...
                </div>
              </div>
            </div>
          </div>
        )}
      </div>
      
      {/* Hover Tooltip for Sensors */}
      {hoveredEntityName && tooltipPosition && (() => {
        console.log('üé® RENDERING TOOLTIP:', hoveredEntityName, 'at', tooltipPosition);
        return (
          <div
            className={styles.hoverTooltip}
            style={{
              left: `${tooltipPosition.x + 15}px`,
              top: `${tooltipPosition.y + 15}px`,
            }}
          >
            {hoveredEntityName}
          </div>
        );
      })()}
    </div>
  );
};
